using Archipelago.UI;
using FishNet;
using FishNet.Object.Helping;
using HarmonyLib;
using MelonLoader;
using MelonLoader.Utils;
using ScheduleOne;
using ScheduleOne.Casino;
using ScheduleOne.Combat;
using ScheduleOne.DevUtilities;
using ScheduleOne.Dialogue;
using ScheduleOne.Economy;
using ScheduleOne.GameTime;
using ScheduleOne.Interaction;
using ScheduleOne.ItemFramework;
using ScheduleOne.Map;
using ScheduleOne.Money;
using ScheduleOne.NPCs;
using ScheduleOne.NPCs.Relation;
using ScheduleOne.Persistence;
using ScheduleOne.PlayerScripts;
using ScheduleOne.Product;
using ScheduleOne.Property;
using ScheduleOne.StationFramework;
using ScheduleOne.UI;
using ScheduleOne.UI.ATM;
using ScheduleOne.UI.Handover;
using ScheduleOne.UI.MainMenu;
using ScheduleOne.UI.Phone.ContactsApp;
using ScheduleOne.UI.Phone.Map;
using ScheduleOne.Vision;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;
using GameConsole = ScheduleOne.Console;

[assembly: MelonInfo(typeof(Archipelago.Archipelago), "ScheduleOneArchipelago", "0.1.0", "Papacester")]
[assembly: MelonGame("TVGS", "Schedule I")]

namespace Archipelago
{
    public class Archipelago : MelonMod
    {
        public override void OnApplicationStart()
        {
            LoggerInstance.Msg($"ScheduleOneArchipelago v{Info.Version} loaded!");
            LoggerInstance.Msg("By Papacester");

            HarmonyInstance.PatchAll();

            var harmony = new HarmonyLib.Harmony("com.papacester.scheduleonearchipelago");
            
            var original = AccessTools.Method(typeof(LoadManager), "TryLoadSaveInfo", new[]
            {
                typeof(string),
                typeof(int),
                typeof(SaveInfo).MakeByRefType(),
                typeof(bool)

            });

            var postfix = AccessTools.Method(typeof(ModEarlyLoadPatch), "Postfix");

            harmony.Patch(original, postfix: new HarmonyMethod(postfix));

        }
    }

    public static class Schedule1PanelManager
    {
        public static GameObject PanelInstance;
        public static Text StatusText;
    }


    [HarmonyPatch(typeof(ScheduleOne.UI.MainMenu.MainMenuScreen), "Awake")]
    public class MainMenuScreen_Awake_Patch
    {
        static void Postfix(ScheduleOne.UI.MainMenu.MainMenuScreen __instance)
        {
            if (Schedule1PanelManager.PanelInstance != null)
                return;

            GameObject panel = Schedule1PanelBuilder.CreatePanel(__instance.transform);
            Schedule1PanelManager.PanelInstance = panel;
            panel.SetActive(false);
        }
    }


    [HarmonyPatch(typeof(ScheduleOne.UI.MainMenu.MainMenuScreen), "Open")]
    public class MainMenuScreen_Open_Patch
    {
        static void Postfix(ScheduleOne.UI.MainMenu.MainMenuScreen __instance)
        {
            if (Schedule1PanelManager.PanelInstance != null)
            {
                Schedule1PanelManager.PanelInstance.SetActive(true);
                Schedule1PanelManager.PanelInstance.transform.SetAsLastSibling();
                MelonLogger.Msg("Reactivating Schedule1Panel");
            }
        }
    }


    [HarmonyPatch(typeof(ScheduleOne.UI.MainMenu.MainMenuScreen), "Close")]
    public class MainMenuScreen_Close_Patch
    {
        static void Postfix(ScheduleOne.UI.MainMenu.MainMenuScreen __instance)
        {
            if (Schedule1PanelManager.PanelInstance != null)
            {
                Schedule1PanelManager.PanelInstance.SetActive(false);
                MelonLogger.Msg("Hiding Schedule1Panel");
            }
        }
    }



    [HarmonyPatch(typeof(SetupScreen), "StartGame")] // Replace with actual class name
    public class ModNewGameResetPatch
    {
        static void Prefix(object __instance)
        {
            var slotIndexField = AccessTools.Field(__instance.GetType(), "slotIndex");
            var defaultUnlockedCustomers = new List<string>
            {
                "Kyle",
                "Austin",
                "Kathy",
                "Mick",
                "Sam",
                "Jessi"
            };
            int slotIndex = (int)slotIndexField.GetValue(__instance);

            string basePath = Singleton<SaveManager>.Instance.IndividualSavesContainerPath;
            string newSaveFolder = Path.Combine(basePath, $"SaveGame_{slotIndex + 1}");
            string key = "Mod_PropertyState_" + newSaveFolder;

            PropertyPurchaseTracker.Purchased.Clear();
            PlayerPrefs.DeleteKey(key);

            CustomerUnlockTracker.ResetAll();
            SampleTracker.ResetAll();


            foreach (var name in defaultUnlockedCustomers)
            {
                CustomerUnlockTracker.SetUnlocked(name, true);
            }

            MelonLogger.Msg($"[ModNewGameResetPatch] New game started in slot {slotIndex + 1}. Mod flags reset.");
        }
    }

    [HarmonyPatch(typeof(GameManager), "Start")]
    public class ModApplyPatch
    {
        static void Prefix()
        {
            string saveFolderPath = Singleton<LoadManager>.Instance.LoadedGameFolderPath;
            string key = "Mod_PropertyState_" + saveFolderPath;

            // Restore default property state
            PropertyPurchaseTracker.RegisterDefaults();
            MelonLogger.Msg($"[ModApplyPatch] Registered {PropertyPurchaseTracker.GetTrackedItems().Count()} mod-managed properties.");

            // Reset sample tracker to static defaults (true for Kyle, etc.)
            SampleTracker.ResetAll();
            MelonLogger.Msg($"[ModApplyPatch] Reset sample tracker to default state with {SampleTracker.Given.Count} recipients.");

            CustomerUnlockTracker.ResetAll();

            if (PlayerPrefs.HasKey(key))
            {
                var json = PlayerPrefs.GetString(key);
                var state = JsonUtility.FromJson<SavedModState>(json);

                // Restore property state
                SweatshopAndMotelRoomCanBuy.alreadypurchasedMotelRoom = PropertyPurchaseTracker.IsPurchased("MotelRoom");
                SweatshopAndMotelRoomCanBuy.alreadypurchasedSweatShop = PropertyPurchaseTracker.IsPurchased("Sweatshop");

                // Apply saved sample state (overwrites static defaults)
                foreach (var name in state.SamplesGiven)
                    SampleTracker.SetGiven(name, true);

                MelonLogger.Msg($"[ModApplyPatch] Restored {state.SamplesGiven.Count} samples from save.");

                // Restore customer unlocks
                foreach (var name in state.UnlockedCustomers)
                    CustomerUnlockTracker.SetUnlocked(name, true);

                MelonLogger.Msg($"[ModApplyPatch] Restored {state.UnlockedCustomers.Count} unlocked customers.");
            }
            else
            {
                MelonLogger.Msg("[ModApplyPatch] No saved mod state found — using default sample and unlock values.");
            }
        }
    }





    [HarmonyPatch(typeof(SaveManager), "Save", new[] { typeof(string) })]
    public class ModSavePatch
    {
        static void Prefix(string saveFolderPath)
        {
            var state = new SavedModState
            {
                PurchasedCodes = PropertyPurchaseTracker.Purchased
                    .Where(kvp => kvp.Value)
                    .Select(kvp => kvp.Key)
                    .ToList(),

                UnlockedCustomers = CustomerUnlockTracker.Unlocked
                    .Where(kvp => kvp.Value)
                    .Select(kvp => kvp.Key)
                    .ToList(),

                SamplesGiven = SampleTracker.Given
                    .Where(kvp => kvp.Value)
                    .Select(kvp => kvp.Key)
                    .ToList()


            };
            MelonLogger.Msg($"[ModSavePatch] Saving {state.SamplesGiven.Count} samples.");
            string json = JsonUtility.ToJson(state);
            string key = "Mod_PropertyState_" + saveFolderPath;
            PlayerPrefs.SetString(key, json);
            PlayerPrefs.Save();

            MelonLogger.Msg($"[ModSavePatch] Saved mod state for: {saveFolderPath}");
            MelonLogger.Msg($"[ModSavePatch] Purchased codes being saved: {string.Join(", ", state.PurchasedCodes)}");

        }
    }


    [HarmonyPatch(typeof(LoadManager), "TryLoadSaveInfo")]
    public class ModEarlyLoadPatch
    {
        static void Postfix(string saveFolderPath, int saveSlotIndex, ref SaveInfo saveInfo)
        {
            string key = "Mod_PropertyState_" + saveFolderPath;

            // Log current sample count (already statically initialized)
            MelonLogger.Msg($"[ModEarlyLoadPatch] Sample tracker contains {SampleTracker.Given.Count} recipients.");

            if (PlayerPrefs.HasKey(key))
            {
                
                
                string json = PlayerPrefs.GetString(key);
                MelonLogger.Msg($"[ModApplyPatch] Raw JSON: {json}");
                var state = JsonUtility.FromJson<SavedModState>(json);

                // Restore property state early
                PropertyPurchaseTracker.Purchased.Clear();
                foreach (var code in state.PurchasedCodes)
                    PropertyPurchaseTracker.SetPurchased(code, true);

                foreach (var name in state.UnlockedCustomers)
                    CustomerUnlockTracker.SetUnlocked(name, true);

                // DO NOT restore samples here — let ModApplyPatch handle it

                MelonLogger.Msg($"[PropertyPurchaseTracker] Tracked items: {string.Join(", ", PropertyPurchaseTracker.GetTrackedItems())}");
                MelonLogger.Msg($"[ModEarlyLoadPatch] Restored purchase state early for: {saveFolderPath}");
                MelonLogger.Msg($"[ModEarlyLoadPatch] Restored {state.UnlockedCustomers.Count} unlocked customers.");
            }

            // Refresh PoI markers
            var allCustomers = GameObject.FindObjectsOfType<Customer>();
            foreach (var customer in allCustomers)
            {
                Patch_UpdatePotentialCustomerPoI.RefreshPoIMarker(customer);
            }

            MelonLogger.Msg("[ModEarlyLoadPatch] Refreshed PoI markers after loading saved sample state.");
        }
    }




    [Serializable]
    public class SavedModState
    {
        public int Version = 1;
        public List<string> PurchasedCodes = new List<string>();
        public List<string> UnlockedCustomers = new List<string>();
        public List<string> SamplesGiven = new List<string>();

    }

    public static class SampleTracker
    {
        public static Dictionary<string, bool> Given = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase)
    {
         //Northtown
        { "Kyle", true },
        { "Austin", true },
        { "Kathy", true },
        { "Mick", true },
        { "Sam", true },
        { "Jessi", true },
        { "Peter", false },
        { "Chloe", false },
        { "Ludwig", false },
        { "Mrs.", false },
        { "Geraldine", false },
        { "Beth", false },
        { "Peggy", false },
        { "Donna", false },
        //Westville
        { "Trent", false },
        { "Meg", false },
        { "Joyce", false },
        { "Keith", false },
        { "Doris", false },
        { "Jerry", false },
        { "Kim", false },
        { "Charles", false },
        { "George", false },
        { "Dean", false },
        //Downtown
        { "Jennifer", false},
        { "Elizabeth", false },
        { "Eugene", false },
        { "Greg", false },
        { "Jeff", false },
        { "Kevin", false },
        { "Louis", false },
        { "Lucy", false },
        { "Philip", false },
        { "Randy", false },
        //Docks
        { "Anna", false},
        { "Billy", false },
        { "Cranky Frank", false },
        { "Genghis", false },
        { "Javier", false },
        { "Lisa", false },
        { "Mac", false },
        { "Marco", false },
        { "Melissa", false },
        //Suburbia
        { "Chris", false},
        { "Allison", false },
        { "Carl", false },
        { "Dennis", false },
        { "Hank", false },
        { "Harold", false },
        { "Jack", false },
        { "Jackie", false },
        { "Jeremy", false },
        { "Karen", false },
        //Uptown
        { "Lily", false },
        { "Fiona", false },
        { "Herbert", false },
        { "Jen", false },
        { "Michael", false },
        { "Pearl", false },
        { "Ray", false },
        { "Tobas", false },
        { "Walter", false }
    };
        private static readonly HashSet<string> DefaultGiven = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "Kyle", "Austin", "Kathy", "Mick", "Sam", "Jessi"
        };

        public static bool HasGiven(string name)
        {
            return Given.TryGetValue(name, out bool value) && value;
        }

        public static void SetGiven(string name, bool value, Customer customer = null)
        {

            if (!Given.ContainsKey(name))
            {
                MelonLogger.Warning($"[SampleTracker] Unknown recipient: {name}");
                return;
            }

            Given[name] = value;
            MelonLogger.Msg($"[SampleTracker] SetGiven: {name} = {value}");

            // Only update marker if customer reference is provided
            if (customer != null)
            {
                var method = AccessTools.Method(customer.GetType(), "UpdatePotentialCustomerPoI");
                if (method != null)
                {
                    try
                    {
                        method.Invoke(customer, null);
                    }
                    catch (Exception ex)
                    {
                        MelonLogger.Warning($"[SampleTracker] Failed to update marker for {customer.name}: {ex.Message}");
                    }
                }
            }

        }


        public static void ResetAll()
        {
            foreach (var key in Given.Keys.ToList())
            {
                Given[key] = DefaultGiven.Contains(key);
            }

            MelonLogger.Msg("[SampleTracker] All sample flags reset (preserved default-true recipients).");
        }


        public static void RegisterDefaults(IEnumerable<string> allCustomerNames)
        {
            foreach (var name in allCustomerNames)
            {
                if (!Given.ContainsKey(name))
                {
                    Given[name] = false;
                    MelonLogger.Msg($"[SampleTracker] Registered: {name}");
                }
            }
        }
    }


    public static class CustomerKey
    {
        public static string Get(Customer c)
        {
            var npc = c?.NPC;
            return npc?.FirstName ?? c?.name ?? "Unknown";
        }
    }


    [HarmonyPatch(typeof(Customer), "SampleOptionValid")]
    public class SampleOptionValidPatch
    {
        // Prefix runs before the original method
        static bool Prefix(Customer __instance, out string invalidReason, ref bool __result)
        {
            string key = CustomerKey.Get(__instance);
            bool regionUnlocked = RegionUtils.IsCustomerRegionUnlocked(__instance);
            bool relationUnlocked = __instance.NPC?.RelationData?.Unlocked ?? false;
            bool hasSample = SampleTracker.HasGiven(key);

            MelonLogger.Msg(
                $"[SampleOptionValid.Prefix] {key} region={regionUnlocked} relation={relationUnlocked} hasSample={hasSample}"
            );

            // If already sampled, block immediately
            if (hasSample)
            {
                invalidReason = "Sample already succeeded";
                __result = false;
                MelonLogger.Msg($"[SampleOptionValid.Prefix] {key} already sampled — blocking and skipping original.");
                return false; // skip original
            }

            // Otherwise let original run
            invalidReason = string.Empty;
            return true;
        }
    }

    [HarmonyPatch(typeof(Customer), "SetUpDialogue")]
    public class Patch_SetUpDialogue
    {
        // Simple debug toggle
        private static bool DebugEnabled = true;

        static void Postfix(Customer __instance)
        {
            var sampleChoiceField = AccessTools.Field(typeof(Customer), "sampleChoice");
            var sampleChoice = (DialogueController.DialogueChoice)sampleChoiceField.GetValue(__instance);

            // Keep references to the original delegates so we can fall back to vanilla behavior
            var origShow = sampleChoice.shouldShowCheck;
            var origValid = sampleChoice.isValidCheck;

            // Track last results to avoid log spam
            bool lastShowResult = false;
            bool lastValidResult = false;

            // Wrap shouldShowCheck: signature is (bool) -> bool
            sampleChoice.shouldShowCheck = new DialogueController.DialogueChoice.ShouldShowCheck(
                (bool arg) =>
                {
                    string key = CustomerKey.Get(__instance);
                    bool relationUnlocked = __instance.NPC?.RelationData?.Unlocked ?? false;

                    bool result = relationUnlocked || (origShow != null && (bool)origShow.DynamicInvoke(arg));

                    if (DebugEnabled && result != lastShowResult)
                    {
                        MelonLogger.Msg($"[SampleChoice.ShowCheck] {key} changed: {lastShowResult} -> {result} (relationUnlocked={relationUnlocked})");
                        lastShowResult = result;
                    }

                    return result;
                }
            );

            // Wrap isValidCheck: signature is (out string invalidReason) -> bool
            sampleChoice.isValidCheck = new DialogueController.DialogueChoice.IsChoiceValid(
                (out string invalidReason) =>
                {
                    string key = CustomerKey.Get(__instance);
                    bool relationUnlocked = __instance.NPC?.RelationData?.Unlocked ?? false;
                    bool hasSample = SampleTracker.HasGiven(key);

                    bool result;
                    if (relationUnlocked && !hasSample)
                    {
                        invalidReason = string.Empty;
                        result = true;
                    }
                    else
                    {
                        object[] args = new object[] { null };
                        result = origValid != null && (bool)origValid.DynamicInvoke(args);
                        invalidReason = (string)args[0] ?? string.Empty;
                    }

                    if (DebugEnabled && result != lastValidResult)
                    {
                        MelonLogger.Msg($"[SampleChoice.ValidCheck] {key} changed: {lastValidResult} -> {result} (relationUnlocked={relationUnlocked}, hasSample={hasSample}, reason={invalidReason})");
                        lastValidResult = result;
                    }

                    return result;
                }
            );

            if (DebugEnabled)
                MelonLogger.Msg($"[Patch_SetUpDialogue] Rewired sampleChoice checks for {CustomerKey.Get(__instance)}");
        }
    }

    public static class CustomerUnlockTracker
    {
        // Current runtime state
        public static Dictionary<string, bool> Unlocked = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);

        // Baseline defaults (who exists + their default unlocked state)
        private static readonly Dictionary<string, bool> DefaultUnlocked = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase)
    {
        // Northtown
        { "Kyle", true },
        { "Austin", true },
        { "Kathy", true },
        { "Mick", true },
        { "Sam", true },
        { "Jessi", true },
        { "Peter", false },
        { "Chloe", false },
        { "Ludwig", false },
        { "Mrs.", false },
        { "Geraldine", false },
        { "Beth", false },
        { "Peggy", false },
        { "Donna", false },

        // Westville
        { "Trent", false },
        { "Meg", false },
        { "Joyce", false },
        { "Keith", false },
        { "Doris", false },
        { "Jerry", false },
        { "Kim", false },
        { "Charles", false },
        { "George", false },
        { "Dean", false },

        // Downtown
        { "Jennifer", false },
        { "Elizabeth", false },
        { "Eugene", false },
        { "Greg", false },
        { "Jeff", false },
        { "Kevin", false },
        { "Louis", false },
        { "Lucy", false },
        { "Philip", false },
        { "Randy", false },

        // Docks
        { "Anna", false },
        { "Billy", false },
        { "Cranky Frank", false },
        { "Genghis", false },
        { "Javier", false },
        { "Lisa", false },
        { "Mac", false },
        { "Marco", false },
        { "Melissa", false },

        // Suburbia
        { "Chris", false },
        { "Allison", false },
        { "Carl", false },
        { "Dennis", false },
        { "Hank", false },
        { "Harold", false },
        { "Jack", false },
        { "Jackie", false },
        { "Jeremy", false },
        { "Karen", false },

        // Uptown
        { "Lily", false },
        { "Fiona", false },
        { "Herbert", false },
        { "Jen", false },
        { "Michael", false },
        { "Pearl", false },
        { "Ray", false },
        { "Tobas", false },
        { "Walter", false }
    };

        // Static constructor ensures defaults are loaded at startup
        static CustomerUnlockTracker()
        {
            ResetAll();
        }

        public static bool IsUnlocked(string name)
        {
            return Unlocked.TryGetValue(name, out bool value) && value;
        }

        public static void SetUnlocked(string name, bool value)
        {
            if (!Unlocked.ContainsKey(name))
            {
                MelonLogger.Warning($"[CustomerUnlockTracker] Unknown customer: {name}");
                return;
            }

            Unlocked[name] = value;
            MelonLogger.Msg($"[CustomerUnlockTracker] SetUnlocked: {name} = {value}");
        }

        public static void ResetAll()
        {
            Unlocked.Clear();
            foreach (var kvp in DefaultUnlocked)
            {
                Unlocked[kvp.Key] = kvp.Value;
            }

            MelonLogger.Msg("[CustomerUnlockTracker] All unlocks reset to defaults.");
        }
    }


    [HarmonyPatch(typeof(Customer), "SampleWasSufficient")]
    public class SampleWasSufficientPatch
    {
        static void Postfix(Customer __instance)
        {
            SampleTracker.SetGiven(__instance.name, true, __instance);
            MelonLogger.Msg($"[SampleWasSufficientPatch] Sample succeeded for {__instance.name}");
        }
    }


    [HarmonyPatch(typeof(NPCRelationData), "Unlock")]
    public class Patch_NPCRelationData_Unlock
    {
        static bool Prefix(NPCRelationData __instance, NPCRelationData.EUnlockType type, bool notify)
        {
            var npc = __instance.NPC;
            if (npc == null)
            {
                MelonLogger.Warning("[Unlock Patch] NPC is null — skipping patch to avoid save crash.");
                return true; // Let original method run
            }

            string name = npc.FirstName ?? npc.name ?? "Unknown";
            Customer customer = npc.GetComponent<Customer>();

            /*
            SampleTracker.SetGiven(name, true);
            if (customer != null)
            {
                SampleTracker.SetGiven(name, true, customer);
            }
            */
            if (CustomerUnlockTracker.IsUnlocked(name))
            {
                MelonLogger.Msg($"[Unlock Allowed] Proceeding with unlock for: {name}");
                return true;
            }

            MelonLogger.Msg($"[Unlock Blocked] {name} is not approved by mod — skipping unlock.");
            return false;
        }
    }

    public static class RegionUtils
    {
        public static bool IsCustomerRegionUnlocked(Customer customer)
        {
            var npcProp = AccessTools.Property(customer.GetType(), "NPC");
            var npc = npcProp?.GetValue(customer);
            if (npc == null) return false;

            var regionField = AccessTools.Field(npc.GetType(), "Region");
            var regionEnum = regionField?.GetValue(npc);
            if (regionEnum == null) return false;

            var mapType = AccessTools.TypeByName("ScheduleOne.Map.Map");
            var mapInstance = AccessTools.Property(mapType, "Instance")?.GetValue(null);
            if (mapInstance == null) return false;

            var getRegionData = AccessTools.Method(mapType, "GetRegionData", new[] { regionEnum.GetType() });
            var regionData = getRegionData?.Invoke(mapInstance, new object[] { regionEnum });
            if (regionData == null) return false;

            var isUnlockedProp = AccessTools.Property(regionData.GetType(), "IsUnlocked");
            return (bool)(isUnlockedProp?.GetValue(regionData) ?? false);
        }
    }

    [HarmonyPatch(typeof(Customer), "UpdatePotentialCustomerPoI")]
    public class Patch_UpdatePotentialCustomerPoI
    {
        static void Prefix(Customer __instance)
        {
            if (__instance?.potentialCustomerPoI == null)
                return;

            if (!SampleEligibility.IsEligible(__instance, out string reason))
            {
                __instance.potentialCustomerPoI.enabled = false;
            }
        }

        public static void RefreshPoIMarker(Customer customer)
        {
            if (customer?.potentialCustomerPoI == null)
                return;

            if (SampleEligibility.IsEligible(customer, out _))
            {
                customer.potentialCustomerPoI.enabled = true;
            }
            else
            {
                customer.potentialCustomerPoI.enabled = false;
            }
        }
    }

    public static class SampleEligibility
    {
        public static bool IsEligible(Customer customer, out string reason)
        {
            if (!RegionUtils.IsCustomerRegionUnlocked(customer))
            {
                reason = "region locked";
                return false;
            }

            if (SampleTracker.HasGiven(customer.name))
            {
                reason = "sample succeeded";
                return false;
            }

            reason = null;
            return true;
        }
    }

    [HarmonyPatch(typeof(Customer), "IsUnlockable")]
    public class Patch_IsUnlockable
    {
        static bool Prefix(Customer __instance, ref bool __result)
        {
            bool regionUnlocked = RegionUtils.IsCustomerRegionUnlocked(__instance);
            if (!regionUnlocked)
            {
                MelonLogger.Msg($"[IsUnlockable Patch] {CustomerKey.Get(__instance)} — region not unlocked, not unlockable.");
                __result = false;
                return false; // skip original
            }

            // Allow original for other checks; AP can still unlock relations
            return true;
        }
    }


    public static class ModUnlockControl
    {
        public static HashSet<string> AllowedUnlocks = new HashSet<string>();

        public static void AllowUnlock(string customerName)
        {
            AllowedUnlocks.Add(customerName);
            MelonLogger.Msg($"[Unlock Allowed] {customerName} added to allowlist.");
        }

        public static bool IsUnlockAllowed(string customerName)
        {
            return AllowedUnlocks.Contains(customerName);
        }
    }


    [HarmonyPatch(typeof(DialogueController_Ming), "CanBuyRoom")]
    public class SweatshopAndMotelRoomCanBuy
    {
        public static bool alreadypurchasedMotelRoom = false;
        public static bool alreadypurchasedSweatShop = false;

        static bool Prefix(DialogueController_Ming __instance, bool enabled, ref bool __result)
        {
            var propertyField = AccessTools.Field(typeof(DialogueController_Ming), "Property");
            var property = propertyField.GetValue(__instance) as Property;

            if (property == null)
            {
                MelonLogger.Warning("[CanBuyRoom] Property field is null.");
                return true; // fallback to original logic
            }

            if (property.name == "MotelRoom" && PropertyPurchaseTracker.IsPurchased("motelroom"))
            {
                __result = false;
                return false; // skip original method
            }

            if (property.name == "Sweatshop" && PropertyPurchaseTracker.IsPurchased("sweatshop"))
            {
                __result = false;
                return false; // skip original method
            }

            //Override: allow purchase regardless of quest state
            __result = true;
            return false; // skip original method
        }
    }



    public static class PropertyPurchaseTracker
    {
            public static Dictionary<string, bool> Purchased { get; private set; } = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
            private static HashSet<string> trackedItems = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            // Called once at startup
            public static void RegisterDefaults()
        {
            Register("motelroom");
            Register("sweatshop");
            Register("storageunit");
            Register("bungalow");
            Register("barn");
            Register("dockswarehouse");
            Register("laundromat");
            Register("carwash");
            Register("postoffice");
            Register("tacoticklers");
        }

        public static void Register(string code)
        {
            if (string.IsNullOrWhiteSpace(code)) return;
            code = code.ToLowerInvariant();
            trackedItems.Add(code);
            if (!Purchased.ContainsKey(code))
                Purchased[code] = false;
            MelonLogger.Msg($"[PropertyPurchaseTracker] Registered: {code}");
        }

        public static bool IsPurchased(string code)
        {
            return Purchased.TryGetValue(code.ToLowerInvariant(), out bool value) && value;
        }

        public static void SetPurchased(string code, bool value)
        {
            if (string.IsNullOrWhiteSpace(code)) return;
            code = code.ToLowerInvariant();
            Purchased[code] = value;
            MelonLogger.Msg($"[PropertyPurchaseTracker] SetPurchased: {code} = {value}");
        }

        public static bool Contains(string code)
        {
            return trackedItems.Contains(code.ToLowerInvariant());
        }

        public static IEnumerable<string> GetTrackedItems() => trackedItems;
    }


    [HarmonyPatch(typeof(DialogueHandler_EstateAgent), "ShouldChoiceBeShown")]
    public class ModShouldChoiceBeShownPatch
    {
        static bool Prefix(string choiceLabel, ref bool __result)
        {
            string normalized = choiceLabel.ToLowerInvariant();
            
            MelonLogger.Msg($"[Patch] Intercepted: {normalized}");
            MelonLogger.Msg($"[Patch] Tracked: {PropertyPurchaseTracker.Contains(normalized)}, Purchased: {PropertyPurchaseTracker.IsPurchased(normalized)}");

            // If tracked but not purchased → show it
            if (PropertyPurchaseTracker.Contains(normalized) && !PropertyPurchaseTracker.IsPurchased(normalized))
            {
                __result = true;
                MelonLogger.Msg($"[ModShouldChoiceBeShownPatch] Showing tracked but unpurchased item: {normalized}");
                return false;
            }

            // If purchased → hide it
            if (PropertyPurchaseTracker.IsPurchased(normalized))
            {
                __result = false;
                MelonLogger.Msg($"[ModShouldChoiceBeShownPatch] Hiding purchased item: {normalized}");
                return false;
            }

            // Fallback to original logic
            return true;
        }
    }

    public static class PurchaseGuard
    {
        public static HashSet<string> RecentlyProcessed = new HashSet<string>();

        public static async void ScheduleClear(float seconds = 1f)
        {
            int ms = (int)(seconds * 1000);
            await Task.Delay(ms);
            RecentlyProcessed.Clear();
            MelonLogger.Msg("[PurchaseGuard] Cleared recently processed purchases.");
        }
    }



    [HarmonyPatch(typeof(DialogueHandler_EstateAgent), "DialogueCallback")]
    public class ModDialogueCallbackPatch
    {
        static bool Prefix(object __instance, string choiceLabel)
        {
            var propertyField = AccessTools.Field(__instance.GetType(), "selectedProperty");
            var businessField = AccessTools.Field(__instance.GetType(), "selectedBusiness");

            var property = propertyField.GetValue(__instance) as Property;
            var business = businessField.GetValue(__instance) as Business;

            string code = property?.PropertyCode.ToLowerInvariant() ?? business?.PropertyCode.ToLowerInvariant();
            if (string.IsNullOrEmpty(code)) return true;

            if (PurchaseGuard.RecentlyProcessed.Contains(code))
            {
                MelonLogger.Msg($"[ModDialogueCallbackPatch] Skipping duplicate purchase for '{code}'.");
                return false;
            }

            PurchaseGuard.RecentlyProcessed.Add(code);
            PurchaseGuard.ScheduleClear();

            if (choiceLabel == "CONFIRM_BUY" && property != null)
            {
                NetworkSingleton<MoneyManager>.Instance.CreateOnlineTransaction(
                    property.PropertyName + " purchase",
                    -property.Price,
                    1f,
                    string.Empty
                );

                property.SetOwned();
                PropertyPurchaseTracker.SetPurchased(code, true);
                MelonLogger.Msg($"[ModDialogueCallbackPatch] Purchased property '{code}' for ${property.Price:N0}.");
                return false;
            }

            if (choiceLabel == "CONFIRM_BUY_BUSINESS" && business != null)
            {
                NetworkSingleton<MoneyManager>.Instance.CreateOnlineTransaction(
                    business.PropertyName + " purchase",
                    -business.Price,
                    1f,
                    string.Empty
                );

                business.SetOwned();
                PropertyPurchaseTracker.SetPurchased(code, true);
                MelonLogger.Msg($"[ModDialogueCallbackPatch] Purchased business '{code}' for ${business.Price:N0}.");
                return false;
            }

            return true;
        }
    }


    [HarmonyPatch(typeof(DialogueHandler_EstateAgent), "ChoiceCallback")]
    public class ModChoiceCallbackPatch
    {
        static void Postfix(object __instance, string choiceLabel)
        {
            string code = choiceLabel.ToLowerInvariant();

            if (PropertyPurchaseTracker.Contains(code) && !PropertyPurchaseTracker.IsPurchased(code))
            {
                var propertyField = AccessTools.Field(__instance.GetType(), "selectedProperty");
                var businessField = AccessTools.Field(__instance.GetType(), "selectedBusiness");

                var property = Property.Properties.Find(p => p.PropertyCode.ToLower() == code);
                var business = Business.Businesses.Find(b => b.PropertyCode.ToLower() == code);

                if (property != null && property.IsOwned)
                {
                    propertyField.SetValue(__instance, property);
                    Traverse.Create(__instance).Method("ChoiceCallback", new[] { typeof(string) }).GetValue("CONFIRM_BUY");
                }
                else if (business != null && business.IsOwned)
                {
                    businessField.SetValue(__instance, business);
                    Traverse.Create(__instance).Method("ChoiceCallback", new[] { typeof(string) }).GetValue("CONFIRM_BUY_BUSINESS");
                }
            }
        }
    }


    [HarmonyPatch(typeof(DialogueHandler_EstateAgent), "CheckChoice")]
    public class ModCheckChoicePatch
    {
        static bool Prefix(string choiceLabel, ref string invalidReason, ref bool __result)
        {
            string code = choiceLabel.ToLowerInvariant();

            if (PropertyPurchaseTracker.Contains(code) && !PropertyPurchaseTracker.IsPurchased(code))
            {
                var property = Property.Properties.Find(p => p.PropertyCode.ToLower() == code);
                var business = Business.Businesses.Find(b => b.PropertyCode.ToLower() == code);

                float price = property?.Price ?? business?.Price ?? -1f;
                float balance = NetworkSingleton<MoneyManager>.Instance.sync___get_value_onlineBalance();

                if (price > 0 && balance < price)
                {
                    invalidReason = "Insufficient balance";
                    __result = false;
                    return false; // Skip original method
                }
            }

            return true; // Let original method handle everything else
        }
    }


    [HarmonyPatch(typeof(DialogueHandler_EstateAgent), "ModifyChoiceText")]
    public class ModPriceInjectionPatch
    {
        static bool Prefix(string choiceLabel, string choiceText, ref string __result)
        {
            string code = choiceLabel.ToLowerInvariant();

            // Only inject price if it's tracked and not purchased
            if (PropertyPurchaseTracker.Contains(code) && !PropertyPurchaseTracker.IsPurchased(code))
            {
                // Try to find the property or business by code
                var property = Property.Properties.Find(p => p.PropertyCode.ToLower() == code);
                var business = Business.Businesses.Find(b => b.PropertyCode.ToLower() == code);

                float price = property?.Price ?? business?.Price ?? -1;

                if (price > 0)
                {
                    string formatted = $"<color=#19BEF0>(${price:N0})</color>";
                    __result = choiceText.Replace("(<PRICE>)", formatted);
                    return false; // Skip original method
                }
            }

            return true; // Let original method handle other cases
        }
    }


    //prevents owning the sweatshop and motel room through normal means

    [HarmonyPatch(typeof(DialogueController_Ming), "ChoiceCallback")]
    public class SweatshopAndMotelRoom
    {

        static bool alreadyloggedMotelRoom = false;
        static bool alreadyloggedSweatShop = false;
        static bool Prefix(DialogueController_Ming __instance, string choiceLabel)
        {
            if (choiceLabel != "CHOICE_CONFIRM")
                return true; // Let original method run

            // Access protected npc field
            var npcField = AccessTools.Field(typeof(DialogueController_Ming), "npc");
            var npc = npcField.GetValue(__instance) as NPC;

            var propertyField = AccessTools.Field(typeof(DialogueController_Ming), "Property");
            var property = propertyField.GetValue(__instance) as Property; 

            // Execute logic
            NetworkSingleton<MoneyManager>.Instance.ChangeCashBalance(-__instance.Price, true, false);
            npc?.Inventory.InsertItem(NetworkSingleton<MoneyManager>.Instance.GetCashInstance(__instance.Price), true);

            __instance.onPurchase?.Invoke();
            if (property.name == "MotelRoom")
            {
                if (!alreadyloggedMotelRoom)
                {
                    alreadyloggedMotelRoom = true;
                    PropertyPurchaseTracker.SetPurchased("motelroom", true);
                    MelonLogger.Msg("property.name == MotelRoom worked");
                }

            }
            if (property.name == "Sweatshop")
            {
                if (!alreadyloggedSweatShop) {
                    alreadyloggedSweatShop = true;
                    PropertyPurchaseTracker.SetPurchased("sweatshop", true);

                    MelonLogger.Msg("property.name == Sweatshop worked");
                }

            }
            MelonLogger.Msg("Blocked Ownership of " + property.name);
            return false; // Skip original method
        }
    }

    [HarmonyPatch(typeof(ProductDefinition), "AddRecipe")]
    public class Patch_Product_AddRecipe
    {
        static void Postfix(ProductDefinition __instance, StationRecipe recipe)
        {
            // This runs after the recipe is added — safe to inspect or react
            MelonLogger.Msg($"[Patch] Recipe added to product: {__instance.name} → {recipe.name}");

            // TODO: Later replace this with an Archipelago item check
            // if (Archipelago.HasReceived("Unlock_" + recipe.name)) { ... }
        }
    }

    //UNLOCKING CUSTOMERS
    public class UnlockingCustomers
    {
        public static void TryUnlockCustomer(string name, string name2, NPCRelationData.EUnlockType type)
        {
            CustomerUnlockTracker.SetUnlocked(name, true);

            var npc = NPCManager.GetNPC(name2);
            var relation = npc?.RelationData;

            if (relation != null && !relation.Unlocked)
                relation.Unlock(type);
        }

    }
    //Unlocking Example
    //UnlockingCustomers.TryUnlockCustomer("Meg", "meg_cooley", NPCRelationData.EUnlockType.DirectApproach);

    [HarmonyPatch(typeof(Customer), "OnCustomerUnlocked")]
    public class OnCustomerUnlockedPatch
    {
        static void Postfix(Customer __instance)
        {
            var field = AccessTools.Field(typeof(Customer), "sampleOfferedToday");
            if (field != null)
            {
                field.SetValue(__instance, false);
                MelonLogger.Msg($"[OnCustomerUnlockedPatch] Reset sampleOfferedToday for {__instance.name} after unlock");
            }
        }
    }

    /* LOGS ALL COMPLETED DEALS */
    [HarmonyPatch(typeof(Customer), "ContractWellReceived")]
    public class ContractWellReceivedListener
    {
        static bool alreadyLoggedContracts = false;

        static void Postfix(Customer __instance, string npcToRecommend)
        {
            if (!alreadyLoggedContracts)
            {

                    MelonLogger.Msg("Contract Well Received");
                    UnlockingCustomers.TryUnlockCustomer("Peter", "peter_file", NPCRelationData.EUnlockType.DirectApproach);
                    alreadyLoggedContracts = true;
                    resetAlreadyLoggedContracts();
            }
        }

        static async void resetAlreadyLoggedContracts()
        {
            await Task.Delay(1000); // 1-second cooldown
            alreadyLoggedContracts = false;
        }

        /* BLOCKS UNLOCKING OF DEALERS AND SUPPLIERS (EXCEPT FOR ALBERT THROUGH NELSON) */
        static bool Prefix(string npcToRecommend)
        {
            var npc = NPCManager.GetNPC(npcToRecommend);
            if (npc is Dealer || npc is Supplier)
            {
                MelonLogger.Msg($"Prevented unlocking of {npcToRecommend}");
                return false; // Skip original method
            }

            return true; // Allow original method to run
        }
    }


    //SLOT MACHINE LISTENER
    [HarmonyPatch(typeof(SlotMachine), "GetWinAmount")]
    public class Patch_GetWinAmount
    {
        // Track which SlotMachines have recently logged
        static HashSet<int> recentlyLogged = new HashSet<int>();

        static bool Prefix(SlotMachine.EOutcome outcome, int betAmount, SlotMachine __instance, ref int __result)
        {
            int id = __instance.GetInstanceID();
            if (recentlyLogged.Contains(id))
                return false;

            switch (outcome)
            {
                case SlotMachine.EOutcome.Jackpot:
                    __result = betAmount * 100;
                    MelonLogger.Msg($"Jackpot! Payout: {__result}");
                    break;
                case SlotMachine.EOutcome.BigWin:
                    __result = betAmount * 25;
                    MelonLogger.Msg($"Big Win! Payout: {__result}");
                    break;
                case SlotMachine.EOutcome.SmallWin:
                    __result = betAmount * 10;
                    MelonLogger.Msg($"Small Win! Payout: {__result}");
                    break;
                case SlotMachine.EOutcome.MiniWin:
                    __result = betAmount * 2;
                    MelonLogger.Msg($"Mini Win! Payout: {__result}");
                    break;
                default:
                    __result = 0;
                    MelonLogger.Msg($"No win. Outcome: {outcome}");
                    break;
            }

            recentlyLogged.Add(id);
            ResetLogFlagAsync(id);
            return false;
        }

        static async void ResetLogFlagAsync(int id)
        {
            await Task.Delay(1000); // 1-second cooldown
            recentlyLogged.Remove(id);
        }
    }


    //BLACK JACK LISTENER
    [HarmonyPatch(typeof(BlackjackGameController), "GetPayout")]
    public class Patch_BlackJackListener
    {
        static HashSet<BlackjackGameController.EPayoutType> loggedPayouts = new HashSet<BlackjackGameController.EPayoutType>();

        static bool Prefix(float bet, BlackjackGameController.EPayoutType payout, ref float __result)
        {
            if (loggedPayouts.Contains(payout))
                return false;

            switch (payout)
            {
                case BlackjackGameController.EPayoutType.Blackjack:
                    __result = bet * 2.5f;
                    MelonLogger.Msg("Blackjack!");
                    break;
                case BlackjackGameController.EPayoutType.Win:
                    __result = bet * 2f;
                    MelonLogger.Msg("Win!");
                    break;
                case BlackjackGameController.EPayoutType.Push:
                    __result = bet;
                    MelonLogger.Msg("Push.");
                    break;
                default:
                    __result = 0f;
                    MelonLogger.Msg("No win.");
                    break;
            }

            loggedPayouts.Add(payout);
            ClearLoggedPayoutsAsync();
            return false;
        }

        static async void ClearLoggedPayoutsAsync()
        {
            await Task.Delay(1000); // Reset after 1 second
            loggedPayouts.Clear();
        }

    }

    [HarmonyPatch(typeof(ATM), "Impacted")]
    public class ATM_impacted_Patch
    {
        public static HashSet<int> loggedATMs = new HashSet<int>();
        static void Prefix(ATM __instance, Impact impact)
        {
            if (__instance.IsBroken)
            {
                return; 
            }
            if (impact.ImpactForce >= 165f || impact.ImpactType == EImpactType.Bullet)
            {
                int id = __instance.GetInstanceID();
                if (!loggedATMs.Contains(id))
                {
                    loggedATMs.Add(id);
                    MelonLogger.Msg($"ATM impacted with force {impact.ImpactForce} of type {impact.ImpactType}");
                }
            }
        }

    }

    [HarmonyPatch(typeof(Player), "SleepStart")]
    public class PlayerSleepStartPatch
    {
        static void Prefix()
        {
            MelonLogger.Msg("Player is going to sleep.");
            ATM_impacted_Patch.loggedATMs.Clear();
        }
    }
}
